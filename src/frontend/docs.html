<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Project Report - KromaVerse</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5, user-scalable=yes" />
  <meta name="description" content="KromaVerse Technical Documentation & Project Report" />
  <link rel="stylesheet" href="main.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600;700&family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    body { line-height: 1.6; }
    .docs-page {
      flex: 1;
      overflow-y: auto;
      padding: 2rem;
      max-width: 1100px;
      margin: 0 auto;
      width: 100%;
    }
    .docs-content {
      background: var(--card-bg);
      border-radius: var(--radius-lg);
      padding: 3rem;
      box-shadow: var(--shadow-md);
      border: 2px solid var(--border-light);
    }
    .docs-content h1 {
      font-family: 'Fredoka', sans-serif;
      font-size: 2.75rem;
      color: var(--accent-primary);
      margin-bottom: 0.5rem;
      border-bottom: 3px solid var(--accent-primary);
      padding-bottom: 0.75rem;
    }
    .docs-content h2 {
      font-family: 'Fredoka', sans-serif;
      font-size: 2rem;
      color: var(--text-primary);
      margin-top: 3rem;
      margin-bottom: 1.25rem;
      padding-bottom: 0.5rem;
      border-bottom: 2px solid var(--border-light);
    }
    .docs-content h3 {
      font-family: 'Fredoka', sans-serif;
      font-size: 1.5rem;
      color: var(--text-primary);
      margin-top: 2rem;
      margin-bottom: 1rem;
    }
    .docs-content h4 {
      font-family: 'Inter', sans-serif;
      font-size: 1.2rem;
      color: var(--text-primary);
      margin-top: 1.5rem;
      margin-bottom: 0.75rem;
      font-weight: 600;
    }
    .docs-content p {
      line-height: 1.9;
      color: var(--text-secondary);
      margin-bottom: 1.25rem;
    }
    .docs-content ul, .docs-content ol {
      margin: 1rem 0 1.5rem 2rem;
      line-height: 1.9;
      color: var(--text-secondary);
    }
    .docs-content li {
      margin-bottom: 0.75rem;
    }
    .docs-content strong {
      color: var(--text-primary);
      font-weight: 600;
    }
    .docs-content code {
      font-family: 'JetBrains Mono', monospace;
      background: var(--bg-secondary);
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
      font-size: 0.9em;
      color: var(--accent-secondary);
    }
    .code-block {
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 1.5rem;
      border-radius: var(--radius-md);
      overflow-x: auto;
      margin: 1.5rem 0;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.9rem;
      line-height: 1.6;
      border: 1px solid #333;
    }
    .info-box {
      background: var(--bg-secondary);
      border-left: 4px solid var(--accent-secondary);
      padding: 1.25rem;
      border-radius: var(--radius-md);
      margin: 1.5rem 0;
    }
    .info-box strong {
      color: var(--accent-secondary);
    }
    .section-divider {
      border: none;
      height: 2px;
      background: linear-gradient(90deg, transparent, var(--border-light), transparent);
      margin: 3rem 0;
    }
    @media (max-width: 768px) {
      .docs-page { padding: 1rem; }
      .docs-content { padding: 1.5rem; }
      .docs-content h1 { font-size: 2rem; }
      .docs-content h2 { font-size: 1.6rem; }
      .docs-content h3 { font-size: 1.3rem; }
      .code-block { padding: 1rem; font-size: 0.85rem; }
    }
  </style>
</head>
<body>
  <header class="topbar">
    <div class="brand">
      <span class="brand-icon">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-label="Palette">
          <circle cx="12" cy="12" r="10" />
          <path d="M7 10a2 2 0 1 1 0-4" />
          <path d="M12 8a2 2 0 1 1 0-4" />
          <path d="M17 10a2 2 0 1 1 0-4" />
          <path d="M15 16c0 1.5-1.2 2-2.5 2H12a3 3 0 0 1 0-6h1.5a3.5 3.5 0 0 1 3.5 3.5" />
        </svg>
      </span>
      <span class="brand-text">KromaVerse</span>
    </div>
    <nav class="menu">
      <a href="/" class="menu-link" aria-label="Canvas">
        <svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
          <path d="M3 12l9-9 9 9" />
          <path d="M4 11v9a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-9" />
        </svg>
        <span>Canvas</span>
      </a>
      <a href="/info" class="menu-link" aria-label="Info">
        <svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
          <circle cx="12" cy="12" r="10" />
          <line x1="12" y1="10" x2="12" y2="16" />
          <circle cx="12" cy="7" r="1" />
        </svg>
        <span>Info</span>
      </a>
      <a href="/docs" class="menu-link" aria-label="Docs">
        <svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
          <path d="M7 2h8l5 5v13a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2z" />
          <path d="M15 2v5h5" />
        </svg>
        <span>Docs</span>
      </a>
      <a href="https://github.com/sea-deep/kromaverse" target="_blank" rel="noopener noreferrer" class="menu-link" aria-label="GitHub">
        <svg class="menu-icon" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
          <path d="M12 2C6.48 2 2 6.58 2 12.14c0 4.47 2.87 8.26 6.84 9.62.5.1.68-.22.68-.48 0-.24-.01-.87-.01-1.71-2.78.62-3.37-1.36-3.37-1.36-.45-1.17-1.11-1.48-1.11-1.48-.91-.63.07-.62.07-.62 1 .07 1.53 1.06 1.53 1.06.9 1.57 2.36 1.12 2.94.86.09-.67.35-1.12.63-1.38-2.22-.26-4.56-1.13-4.56-5 0-1.11.39-2.02 1.03-2.73-.1-.26-.45-1.3.1-2.71 0 0 .84-.27 2.75 1.04a9.38 9.38 0 0 1 5 0c1.9-1.31 2.74-1.04 2.74-1.04.55 1.41.2 2.45.1 2.71.64.71 1.03 1.62 1.03 2.73 0 3.88-2.34 4.74-4.57 4.99.36.32.68.95.68 1.92 0 1.39-.01 2.51-.01 2.85 0 .26.18.58.69.48A10.02 10.02 0 0 0 22 12.14C22 6.58 17.52 2 12 2z" />
        </svg>
        <span>GitHub</span>
      </a>
    </nav>
  </header>

  <main class="docs-page">
    <div class="docs-content">
      <h1>üìö KromaVerse Project Report</h1>
      <p style="font-size:1.1rem;color:var(--text-primary);margin-bottom:2rem;">A comprehensive technical documentation of the collaborative pixel art platform</p>

      <hr class="section-divider">

      <h2>üéØ Project Overview</h2>
      <p><strong>KromaVerse</strong> is a real-time collaborative pixel art canvas inspired by Reddit's r/place. It allows multiple users to place colored pixels on a shared 128√ó128 grid, creating a dynamic and ever-evolving digital canvas. The project implements a turn-based rate limiting system to balance user participation while preventing spam.</p>

      <div class="info-box">
        <strong>Key Features:</strong>
        <ul style="margin-left:1.5rem;margin-top:0.5rem;">
          <li>128√ó128 shared canvas with real-time updates via WebSocket</li>
          <li>Turn-based rate limiting (64 turns, 1 per 10s refill)</li>
          <li>24 preset colors + custom color picker with personal history</li>
          <li>Canvas optimization using HTML5 Canvas API (replaced 16k DOM elements)</li>
          <li>User authentication with session management</li>
          <li>MongoDB persistence for pixels and user data</li>
        </ul>
      </div>

      <h2>üèóÔ∏è System Architecture</h2>

      <h3>Technology Stack</h3>
      <ul>
        <li><strong>Backend:</strong> Node.js with Express 5.1.0</li>
        <li><strong>Real-time Communication:</strong> Socket.IO 4.8.1</li>
        <li><strong>Database:</strong> MongoDB 8.19.4 with Mongoose ODM</li>
        <li><strong>Session Management:</strong> express-session with MongoStore</li>
        <li><strong>Authentication:</strong> bcrypt for password hashing</li>
        <li><strong>Frontend:</strong> Vanilla JavaScript with Canvas API</li>
        <li><strong>Styling:</strong> Custom CSS with CSS Variables</li>
      </ul>

      <h3>Project Structure</h3>
      <div class="code-block">src/
‚îú‚îÄ‚îÄ index.js              # Express server, Socket.IO, API routes
‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îú‚îÄ‚îÄ User.js          # User schema (auth, turns, custom colors)
‚îÇ   ‚îî‚îÄ‚îÄ Pixel.js         # Pixel schema (position, color, owner)
‚îî‚îÄ‚îÄ frontend/
    ‚îú‚îÄ‚îÄ index.html       # Main canvas interface
    ‚îú‚îÄ‚îÄ info.html        # User guide
    ‚îú‚îÄ‚îÄ docs.html        # Technical documentation
    ‚îú‚îÄ‚îÄ main.js          # Client-side logic
    ‚îî‚îÄ‚îÄ main.css         # Styles</div>

      <hr class="section-divider">

      <h2>üîß Backend Architecture</h2>

      <h3>Server Configuration (src/index.js)</h3>
      <p>The backend is built on Express.js with Socket.IO for real-time bidirectional communication between server and clients.</p>

      <h4>Core Dependencies</h4>
<div class="code-block">const express = require('express');
const { createServer } = require('http');
const { Server } = require('socket.io');
const mongoose = require('mongoose');
const bcrypt = require('bcrypt');
const session = require('express-session');
const MongoStore = require('connect-mongo');</div>

      <h4>Session Management</h4>
      <p>Sessions are stored in MongoDB using <code>connect-mongo</code> to persist user authentication across server restarts. Sessions are configured with:</p>
      <ul>
        <li><strong>Secret:</strong> Environment variable for session signing</li>
        <li><strong>Cookie Settings:</strong> HttpOnly, SameSite: 'lax', 7-day maxAge</li>
        <li><strong>Proxy Trust:</strong> Enabled for deployment behind reverse proxies</li>
        <li><strong>Resave & SaveUninitialized:</strong> Both false for optimal performance</li>
      </ul>

      <h4>Socket.IO Integration</h4>
      <p>Socket.IO is integrated with Express session middleware to access user sessions in Socket.IO event handlers:</p>
<div class="code-block">io.use((socket, next) => {
  sessionMiddleware(socket.request, {}, next);
});</div>
      <p>This allows retrieving <code>socket.request.session.userId</code> in real-time events like <code>place_pixel</code>.</p>

      <h3>Data Models</h3>

      <h4>User Model (src/models/User.js)</h4>
<div class="code-block">const UserSchema = new mongoose.Schema({
  username: { type: String, required: true, unique: true },
  password: { type: String, required: true }, // bcrypt hashed
  pixelsPlaced: { type: Number, default: 0 },
  lastPlacedAt: Date,
  turnsRemaining: { type: Number, default: 64 },
  lastTurnRefill: Date,
  customColors: [String] // Last 6 custom colors (hex format)
});</div>
      <p><strong>Purpose:</strong> Stores user credentials, rate limiting state, and personalized color preferences.</p>

      <h4>Pixel Model (src/models/Pixel.js)</h4>
<div class="code-block">const PixelSchema = new mongoose.Schema({
  x: { type: Number, required: true },
  y: { type: Number, required: true },
  color: { type: String, required: true },
  user: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
  updatedAt: { type: Date, default: Date.now }
});
PixelSchema.index({ x: 1, y: 1 }, { unique: true });</div>
      <p><strong>Purpose:</strong> Stores pixel state on the canvas. Compound index on <code>(x, y)</code> ensures uniqueness and fast lookups.</p>

      <h3>API Endpoints</h3>

      <h4>Authentication Endpoints</h4>
      <ul>
        <li><code>POST /api/register</code> ‚Äî Creates new user with hashed password</li>
        <li><code>POST /api/login</code> ‚Äî Authenticates user and creates session</li>
        <li><code>POST /api/logout</code> ‚Äî Destroys session</li>
        <li><code>GET /api/me</code> ‚Äî Returns current user data with turn refill calculation</li>
      </ul>

      <h4>Data Endpoints</h4>
      <ul>
        <li><code>GET /api/pixels</code> ‚Äî Returns all placed pixels for canvas initialization</li>
        <li><code>POST /api/color</code> ‚Äî Saves custom color to user's history (last 6 max)</li>
      </ul>

      <h3>Real-time Events (Socket.IO)</h3>

      <h4>Client ‚Üí Server Events</h4>
      <p><strong><code>place_pixel</code></strong> ‚Äî Triggered when user clicks a cell</p>
      <div class="code-block">socket.on('place_pixel', async ({ x, y, color }) => {
  // 1. Validate session and get user
  // 2. Check rate limits (refill if at 0)
  // 3. Verify turns available
  // 4. Consume 1 turn
  // 5. Update/create pixel in database
  // 6. Broadcast to all clients
  // 7. Send turn update to user
});</div>

      <h4>Server ‚Üí Client Events</h4>
      <ul>
        <li><code>pixel_update</code> ‚Äî Broadcasts pixel placement to all connected clients</li>
        <li><code>turns_update</code> ‚Äî Sends updated turn count to specific user</li>
        <li><code>err</code> ‚Äî Sends error messages (not-auth, no-turns, etc.)</li>
      </ul>

      <hr class="section-divider">

      <h2>‚ö° Rate Limiting System</h2>
      <p>The turn-based rate limiting system is the core mechanism controlling user activity. It prevents spam while encouraging strategic pixel placement.</p>

      <h3>System Logic</h3>
      <div class="info-box">
        <strong>Rate Limiting Rules:</strong>
        <ol style="margin-left:1.5rem;margin-top:0.5rem;">
          <li>Users start with 64 turns (MAX_TURNS)</li>
          <li>Each pixel placement consumes 1 turn</li>
          <li>Refilling ONLY starts when turns reach exactly 0</li>
          <li>Refill rate: +1 turn per 10 seconds (TURN_REFILL_MS = 10000ms)</li>
          <li>Refilling stops when turns reach 64</li>
          <li>Admin users bypass all rate limits</li>
        </ol>
      </div>

      <h3>Server-side Implementation</h3>
      <p>The rate limiting logic runs during <code>place_pixel</code> event handling:</p>
<div class="code-block">// Step 1: Refill check (only if at 0 turns)
if (user.turnsRemaining === 0 && user.lastTurnRefill) {
  const now = Date.now();
  const msSinceRefill = now - user.lastTurnRefill.getTime();
  const turnsToRefill = Math.floor(msSinceRefill / TURN_REFILL_MS);
  
  if (turnsToRefill > 0) {
    // Refill turns (cap at MAX_TURNS)
    user.turnsRemaining = Math.min(MAX_TURNS, turnsToRefill);
    // Update refill timestamp
    user.lastTurnRefill = new Date(
      user.lastTurnRefill.getTime() + (turnsToRefill * TURN_REFILL_MS)
    );
    
    // Clear timer if maxed out
    if (user.turnsRemaining >= MAX_TURNS) {
      user.lastTurnRefill = null;
    }
  }
}

// Step 2: Check turns availability
if (user.turnsRemaining <= 0) {
  return socket.emit('err', 'no-turns');
}

// Step 3: Consume turn
user.turnsRemaining--;

// Step 4: Start refill timer if hit 0
if (user.turnsRemaining === 0) {
  user.lastTurnRefill = new Date(now);
}</div>

      <h3>Client-side Refill Timer</h3>
      <p>The client displays a countdown timer when turns reach 0, polling the server every second to check for refilled turns:</p>
<div class="code-block">function startRefillTimer() {
  if (turnsRemaining === 0 && lastTurnRefill) {
    refillTimerEl.style.display = 'block';
    
    refillTimerInterval = setInterval(async () => {
      const now = Date.now();
      const msSinceRefill = now - lastTurnRefill;
      const secondsUntilNext = Math.ceil(
        (refillMs - (msSinceRefill % refillMs)) / 1000
      );
      
      // Update countdown display
      document.getElementById('refillSeconds').textContent = secondsUntilNext;
      
      // Check if turns should be refilled
      const turnsToRefill = Math.floor(msSinceRefill / refillMs);
      if (turnsToRefill > 0) {
        // Fetch updated turns from server
        const response = await fetch('/api/me');
        const data = await response.json();
        turnsRemaining = data.user.turnsRemaining;
        updateTurnsDisplay();
        
        // Stop timer if turns refilled
        if (turnsRemaining > 0) {
          clearInterval(refillTimerInterval);
          refillTimerEl.style.display = 'none';
        }
      }
    }, 1000);
  }
}</div>

      <h3>Admin Bypass</h3>
      <p>Users with username <code>'admin'</code> bypass all rate limiting for moderation purposes:</p>
<div class="code-block">if (user.username !== ADMIN_USERNAME) {
  // Rate limiting logic
}</div>

      <hr class="section-divider">

      <h2>üé® Frontend Architecture</h2>

      <h3>Canvas Rendering System</h3>
      <p>The canvas was originally implemented with 16,384 individual <code>&lt;div&gt;</code> elements (128√ó128 grid), consuming ~822MB RAM. This was optimized by replacing the DOM-based approach with a single HTML5 <code>&lt;canvas&gt;</code> element, reducing memory usage to ~50-100MB.</p>

      <h4>Canvas Initialization</h4>
<div class="code-block">const gridCanvas = document.getElementById('gridCanvas');
const gridCtx = gridCanvas.getContext('2d', { alpha: false });

// Set canvas dimensions
gridCanvas.width = GRID_SIZE * CELL_SIZE;  // 128 * 10 = 1280px
gridCanvas.height = GRID_SIZE * CELL_SIZE;

// Disable image smoothing for crisp pixels
gridCtx.imageSmoothingEnabled = false;

// Fill with white background
gridCtx.fillStyle = '#FFFFFF';
gridCtx.fillRect(0, 0, gridCanvas.width, gridCanvas.height);

// Draw grid lines
gridCtx.strokeStyle = 'rgba(203, 213, 224, 0.4)';
gridCtx.lineWidth = 0.5;
for (let i = 0; i <= GRID_SIZE; i++) {
  // Vertical & horizontal lines
  gridCtx.beginPath();
  gridCtx.moveTo(i * CELL_SIZE, 0);
  gridCtx.lineTo(i * CELL_SIZE, gridCanvas.height);
  gridCtx.stroke();
  // ... horizontal lines
}</div>

      <h4>Pixel Painting Function</h4>
<div class="code-block">function paintCell(x, y, color) {
  if (!gridCtx) return;
  
  // Fill cell with color
  gridCtx.fillStyle = color;
  gridCtx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
  
  // Redraw grid border for this cell
  gridCtx.strokeStyle = 'rgba(203, 213, 224, 0.4)';
  gridCtx.lineWidth = 0.5;
  gridCtx.strokeRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
}</div>

      <h3>Pan & Zoom System</h3>
      <p>Canvas transform is managed via CSS <code>transform</code> property for hardware-accelerated rendering:</p>
<div class="code-block">function updateTransform() {
  // Calculate pan limits (75% beyond edges)
  const canvasSize = GRID_SIZE * CELL_SIZE * scale;
  const maxPan = canvasSize * 0.75;
  
  // Clamp translate values
  translateX = Math.max(-maxPan, Math.min(maxPan, translateX));
  translateY = Math.max(-maxPan, Math.min(maxPan, translateY));
  
  // Apply transform
  gridCanvas.style.transform = `
    translate(-50%, -50%)
    translate(${translateX}px, ${translateY}px)
    scale(${scale})
  `;
}</div>

      <h4>Input Handling</h4>
      <ul>
        <li><strong>Zoom:</strong> Mouse wheel event adjusts <code>scale</code> variable (0.5x - 3x)</li>
        <li><strong>Pan:</strong> Mouse/touch drag updates <code>translateX/Y</code> variables</li>
        <li><strong>Click Detection:</strong> Converts screen coordinates to grid coordinates accounting for transform</li>
      </ul>

<div class="code-block">function onCanvasClick(e) {
  const rect = gridCanvas.getBoundingClientRect();
  const clientX = e.type === 'touchend' 
    ? e.changedTouches[0].clientX 
    : e.clientX;
  const clientY = e.type === 'touchend' 
    ? e.changedTouches[0].clientY 
    : e.clientY;
  
  // Convert screen coordinates to canvas coordinates
  const canvasX = (clientX - rect.left) / (rect.width / GRID_SIZE);
  const canvasY = (clientY - rect.top) / (rect.height / GRID_SIZE);
  
  const gridX = Math.floor(canvasX);
  const gridY = Math.floor(canvasY);
  
  // Emit pixel placement
  socket.emit('place_pixel', { x: gridX, y: gridY, color: currentColor });
}</div>

      <h3>Color Palette System</h3>
      <p>The palette combines 24 preset colors with a custom picker. User's last 6 custom colors replace the tail of the preset palette.</p>

<div class="code-block">const BASE_PALETTE = [
  '#FF0000','#FF7F00','#FFB300','#FFFF00',
  '#A8FF00','#00FF00','#00FF7F','#00FFC8',
  '#00FFFF','#00BFFF','#008CFF','#0000FF',
  '#4B0082','#8B00FF','#FF00FF','#FF69B4',
  '#FF1493','#DC143C','#8B4513','#000000',
  '#808080','#C0C0C0','#FFFFFF','#FFD700'
];

function rebuildPalette() {
  const displayColors = [...BASE_PALETTE];
  
  // Replace last 6 with user's custom colors
  if (customColors.length > 0) {
    const replaceCount = Math.min(6, customColors.length);
    const startIdx = BASE_PALETTE.length - replaceCount;
    customColors.slice(-6).forEach((c, i) => {
      displayColors[startIdx + i] = c;
    });
  }
  
  // Render swatches + picker
  // ...
}</div>

      <h4>Custom Color Saving</h4>
      <p>When a user picks a custom color, it's debounced (500ms) to prevent database spam during color slider dragging:</p>
<div class="code-block">colorPickerInp.addEventListener('input', () => {
  clearTimeout(pickerDebounceTimer);
  pickerDebounceTimer = setTimeout(async () => {
    if (!user) return;
    const color = colorPickerInp.value.toUpperCase();
    
    // Save to server
    await fetch('/api/color', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ color })
    });
    
    // Update local array
    customColors = customColors.filter(c => c !== color);
    customColors.push(color);
    if (customColors.length > 6) customColors.shift();
    
    rebuildPalette();
  }, 500);
});</div>

      <h3>Real-time Updates</h3>
      <p>Socket.IO handlers ensure all clients see pixel updates instantly:</p>
<div class="code-block">socket.on('pixel_update', ({ x, y, color, user: username }) => {
  paintCell(x, y, color);
  pixelCount++;
  updatePixelCount();
  
  // Update own pixel count if this was our pixel
  if (username === user?.username) {
    user.pixelsPlaced++;
    document.getElementById('pixelsCount').textContent = user.pixelsPlaced;
  }
});

socket.on('turns_update', (data) => {
  turnsRemaining = data.turnsRemaining;
  lastTurnRefill = data.lastTurnRefill;
  updateTurnsDisplay();
  startRefillTimer();
});</div>

      <hr class="section-divider">

      <h2>üîê Security & Session Management</h2>

      <h3>Password Security</h3>
      <ul>
        <li><strong>Hashing:</strong> Passwords hashed with bcrypt (10 rounds) before storage</li>
        <li><strong>No plaintext:</strong> Original passwords never stored in database</li>
        <li><strong>Verification:</strong> <code>bcrypt.compare()</code> used for login authentication</li>
      </ul>

      <h3>Session Security</h3>
      <ul>
        <li><strong>HttpOnly cookies:</strong> Prevents JavaScript access to session cookies</li>
        <li><strong>SameSite: lax:</strong> CSRF protection while allowing navigation</li>
        <li><strong>Secure in production:</strong> HTTPS-only cookies when NODE_ENV=production</li>
        <li><strong>MongoDB persistence:</strong> Sessions survive server restarts</li>
      </ul>

      <h3>Input Validation</h3>
      <ul>
        <li><strong>Coordinates:</strong> Validated to be within 0-127 range</li>
        <li><strong>Color format:</strong> Regex <code>/^#[0-9A-Fa-f]{6}$/</code> ensures valid hex</li>
        <li><strong>Username uniqueness:</strong> Enforced by MongoDB unique index</li>
      </ul>

      <hr class="section-divider">

      <h2>üìä Performance Optimizations</h2>

      <h3>Canvas Rendering</h3>
      <ul>
        <li><strong>DOM reduction:</strong> 16,384 divs ‚Üí 1 canvas element (~94% memory reduction)</li>
        <li><strong>Hardware acceleration:</strong> CSS transforms leverage GPU</li>
        <li><strong>No anti-aliasing:</strong> <code>imageSmoothingEnabled: false</code> for crisp pixels</li>
      </ul>

      <h3>Database Optimization</h3>
      <ul>
        <li><strong>Compound index:</strong> <code>(x, y)</code> on Pixel collection for O(1) lookups</li>
        <li><strong>Upsert operations:</strong> Single query for pixel update/create</li>
        <li><strong>Selective field queries:</strong> <code>.select()</code> reduces data transfer</li>
      </ul>

      <h3>Network Optimization</h3>
      <ul>
        <li><strong>WebSocket compression:</strong> Socket.IO compresses messages automatically</li>
        <li><strong>Debounced inputs:</strong> Color picker saves debounced 500ms</li>
        <li><strong>Optimistic rendering:</strong> Pixels painted immediately before server confirmation</li>
      </ul>

  
      <hr class="section-divider">

      <h2>üèÅ Conclusion</h2>
      <p>KromaVerse demonstrates a complete full-stack real-time web application with:</p>
      <ul>
        <li>Efficient real-time communication via WebSocket</li>
        <li>Scalable database design with MongoDB</li>
        <li>Performance-optimized canvas rendering</li>
        <li>Turn-based rate limiting system</li>
        <li>Secure user authentication and session management</li>
        <li>Responsive UI with touch/mouse input handling</li>
      </ul>
      <p>The project successfully balances user experience, performance, and security while providing a foundation for future collaborative canvas features.</p>

      <div class="info-box" style="margin-top:2rem;">
        <strong>Project Repository:</strong> <a href="https://github.com/sea-deep/kromaverse" style="color:var(--accent-secondary);">github.com/sea-deep/kromaverse</a><br>
        <strong>Live Demo:</strong> <a href="/" style="color:var(--accent-secondary);">Canvas Interface</a>
      </div>
    </div>
  </main>
</body>
</html>
